<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generator hase≈Ç</title>
    <meta name="description" content="Bezpieczny generator hase≈Ç oparty na literaturze polskiej. Generuje cztery warianty hase≈Ç o r√≥≈ºnych d≈Çugo≈õciach z transkrypcjƒÖ fonetycznƒÖ." />

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîê</text></svg>" />

    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:; connect-src 'self';" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(1000px 600px at 10% 10%, #e9f2ff 0%, #f7f7f7 45%, #ffffff 100%);
        color: #111;
      }
      .card {
        width: min(720px, 92vw);
        padding: 32px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
        display: grid;
        gap: 16px;
      }
      .password-grid {
        display: grid;
        gap: 16px;
      }
      .password-card {
        padding: 16px;
        border-radius: 12px;
        border: 1px solid #d7e0ff;
        background: #f8faff;
        display: grid;
        gap: 12px;
      }
      h1 {
        margin: 0;
        font-size: 24px;
      }
      h2 {
        margin: 0;
        font-size: 18px;
      }
      .password {
        font-size: clamp(20px, 3vw, 30px);
        font-weight: 700;
        letter-spacing: 0.5px;
        word-break: break-word;
        padding: 16px;
        border-radius: 12px;
        background: #f1f5ff;
        border: 1px solid #d7e0ff;
      }
      .transcription {
        font-size: clamp(11px, 1.5vw, 13px);
        font-weight: 500;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      button {
        border: 0;
        padding: 10px 16px;
        border-radius: 10px;
        background: #3b6ef5;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #2f5fe0;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      button.loading {
        opacity: 0.7;
        cursor: wait;
      }
      button.loading::after {
        content: "...";
        animation: dots 1.5s steps(4, end) infinite;
      }
      @keyframes dots {
        0%, 20% { content: "."; }
        40% { content: ".."; }
        60%, 100% { content: "..."; }
      }
      .muted {
        color: #666;
        font-size: 14px;
      }
      .footer {
        font-size: 13px;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: radial-gradient(1000px 600px at 10% 10%, #1b2433 0%, #0f1117 50%, #0b0d12 100%);
          color: #f5f5f5;
        }
        .card {
          background: rgba(18, 20, 26, 0.9);
          box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        }
        .password-card {
          background: #121821;
          border-color: #25314b;
        }
        .password {
          background: #141a24;
          border-color: #25314b;
        }
        .muted {
          color: #aab0bb;
        }
      }
    </style>
  </head>
  <body>
    <noscript>
      <div style="padding: 20px; text-align: center; background: #fff3cd; color: #856404; border: 1px solid #ffeeba; margin: 20px; border-radius: 8px;">
        <strong>JavaScript jest wymagany</strong><br>
        Ta aplikacja wymaga w≈ÇƒÖczonego JavaScript do dzia≈Çania. Proszƒô w≈ÇƒÖczyƒá JavaScript w przeglƒÖdarce.
      </div>
    </noscript>
    <main class="card">
      <h1>Generator hase≈Ç</h1>
      <p class="muted">Cztery propozycje hase≈Ç o r√≥≈ºnych d≈Çugo≈õciach. Ka≈ºda propozycja ma w≈ÇasnƒÖ transkrypcjƒô.</p>
      <details class="muted" style="font-size: 13px; cursor: pointer;">
        <p style="margin: 8px 0 0 0;">KsiƒÖ≈ºki pochodzƒÖ z <a href="https://wolnelektury.pl" target="_blank" rel="noopener">WolneLektury.pl</a>.</p>
      </details>
      <div class="password-grid">
        <section class="password-card" aria-live="polite">
          <h2 id="title-ascii">Has≈Ço dobre (bez polskich diakrytycznych)</h2>
          <div id="password-ascii" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-ascii" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="sentence-ascii" class="muted" style="font-style: italic;">Zdanie: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="ascii" disabled aria-label="Skopiuj has≈Ço dobre">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2 id="title-long">Has≈Ço d≈Çugie</h2>
          <div id="password-long" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-long" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="sentence-long" class="muted" style="font-style: italic;">Zdanie: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="long" disabled aria-label="Skopiuj has≈Ço d≈Çugie">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2 id="title-ascii-short">Has≈Ço kr√≥tkie (bez polskich diakrytycznych)</h2>
          <div id="password-ascii-short" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-ascii-short" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="sentence-ascii-short" class="muted" style="font-style: italic;">Zdanie: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="ascii-short" disabled aria-label="Skopiuj has≈Ço kr√≥tkie ASCII">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2 id="title-medium">Has≈Ço ≈õrednie</h2>
          <div id="password-medium" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-medium" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="sentence-medium" class="muted" style="font-style: italic;">Zdanie: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="medium" disabled aria-label="Skopiuj has≈Ço ≈õrednie">Skopiuj has≈Ço</button>
        </section>
      </div>
      <div class="row">
        <button id="regen" type="button" aria-label="Wygeneruj nowe has≈Ça">Wygeneruj ponownie</button>
        <button id="clear-exclusions" type="button" style="background: #666;" aria-label="Wyczy≈õƒá historiƒô wykluczonych s≈Ç√≥w">Wyczy≈õƒá historiƒô</button>
        <span class="muted">Has≈Ça zawierajƒÖ cyfrƒô oraz znak specjalny.</span>
      </div>
      <div class="row">
        <span id="exclusion-stats" class="muted">Wykluczone s≈Çowa: 0</span>
      </div>
      <footer class="muted footer">
        Strona nie przechowuje wygenerowanych hase≈Ç. Repozytorium:
        <a href="https://github.com/enclude/www.hasla.zjawa.it" target="_blank" rel="noopener noreferrer">github.com/enclude/www.hasla.zjawa.it</a>.
        Licencja: CC BY 4.0 ‚Äî wymagane wskazanie ≈∫r√≥d≈Ça i tw√≥rcy.
      </footer>
    </main>

    <script>
      // Sprawd≈∫ czy tryb API (parametr ?api w URL)
      const isApiMode = new URLSearchParams(window.location.search).has('api');

      // Lista plik√≥w ≈∫r√≥d≈Çowych - ≈Çadowana dynamicznie z sources.json
      let SOURCE_FILES = [];

      const DIGITS = "0123456789";
      const SPECIALS = "!@#$%^&*()-_=+[]{};:,.?/|";
      
      // Minimalne wymagania dla linijki
      const MIN_WORDS_IN_LINE = 5;
      const MIN_CHARS_IN_LINE = 24;

      // Parametry generowania hase≈Ç
      const MAX_PASSWORD_ATTEMPTS = 200;
      const MAX_LINES_TO_USE = 50;
      
      // Mechanizm wyklucze≈Ñ - u≈ºyte s≈Çowa sƒÖ wykluczane na okre≈õlony czas
      const EXCLUSION_STORAGE_KEY = "hasla_excluded_words";
      const EXCLUSION_TIME_MS = 24 * 60 * 60 * 1000 * 31; // 31 dni
      const MAX_EXCLUDED_WORDS = 1500; // Maksymalna liczba wykluczonych s≈Ç√≥w

      const regenBtn = document.getElementById("regen");
      const copyButtons = Array.from(document.querySelectorAll(".copy-btn"));

      const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

      // === Mechanizm wyklucze≈Ñ ===
      
      // Pobiera listƒô wykluczonych s≈Ç√≥w z localStorage
      const getExcludedWords = () => {
        try {
          const data = localStorage.getItem(EXCLUSION_STORAGE_KEY);
          if (!data) return {};
          return JSON.parse(data);
        } catch {
          return {};
        }
      };

      // Zapisuje listƒô wykluczonych s≈Ç√≥w do localStorage
      const saveExcludedWords = (excluded) => {
        try {
          localStorage.setItem(EXCLUSION_STORAGE_KEY, JSON.stringify(excluded));
        } catch {
          // localStorage mo≈ºe byƒá pe≈Çny lub niedostƒôpny
        }
      };

      // Czy≈õci przeterminowane wykluczenia
      const cleanExpiredExclusions = () => {
        const excluded = getExcludedWords();
        const now = Date.now();
        let cleaned = false;
        
        for (const [word, timestamp] of Object.entries(excluded)) {
          if (now - timestamp > EXCLUSION_TIME_MS) {
            delete excluded[word];
            cleaned = true;
          }
        }
        
        if (cleaned) {
          saveExcludedWords(excluded);
        }
        
        return excluded;
      };

      // Dodaje s≈Çowa do listy wyklucze≈Ñ
      const excludeWords = (wordsToExclude) => {
        const excluded = getExcludedWords();
        const now = Date.now();
        
        for (const word of wordsToExclude) {
          const normalizedWord = word.toLowerCase();
          excluded[normalizedWord] = now;
        }
        
        // Ogranicz rozmiar listy wyklucze≈Ñ
        const entries = Object.entries(excluded);
        if (entries.length > MAX_EXCLUDED_WORDS) {
          // Usu≈Ñ najstarsze wpisy
          entries.sort((a, b) => a[1] - b[1]);
          const toKeep = entries.slice(-MAX_EXCLUDED_WORDS);
          const newExcluded = Object.fromEntries(toKeep);
          saveExcludedWords(newExcluded);
        } else {
          saveExcludedWords(excluded);
        }
      };

      // Sprawdza, czy s≈Çowo jest wykluczone
      const isWordExcluded = (word) => {
        const excluded = getExcludedWords();
        const normalizedWord = word.toLowerCase();
        const timestamp = excluded[normalizedWord];
        
        if (!timestamp) return false;
        
        // Sprawd≈∫, czy wykluczenie nie wygas≈Ço
        return (Date.now() - timestamp) <= EXCLUSION_TIME_MS;
      };

      // Zwraca statystyki wyklucze≈Ñ
      const getExclusionStats = () => {
        const excluded = cleanExpiredExclusions();
        return Object.keys(excluded).length;
      };

      // === Koniec mechanizmu wyklucze≈Ñ ===

      // Usuwa znaki interpunkcyjne ze s≈Çowa
      const removePunctuation = (text) => 
        text.replace(/[.,;:!?‚Äû""''¬´¬ª()[\]{}<>‚Äî‚Äì\-\/\\‚Ä¶'"]/g, "");

      const normalizeWord = (word, forceCase) => {
        if (forceCase === "lower") return word.toLowerCase();
        if (forceCase === "upper") return word.toUpperCase();
        return Math.random() < 0.5 ? word.toLowerCase() : word.toUpperCase();
      };

      const ICAO_PL = {
        a: "Alicja",
        b: "Barbara",
        c: "Celina",
        d: "Danuta",
        e: "Ewa",
        f: "Franciszka",
        g: "Gra≈ºyna",
        h: "Halina",
        i: "Irena",
        j: "Jadwiga",
        k: "Krystyna",
        l: "Lucyna",
        m: "Maria",
        n: "Natalia",
        o: "Olga",
        p: "Patrycja",
        q: "Quentina",
        r: "Renata",
        s: "Sabina",
        t: "Teresa",
        u: "Urszula",
        v: "Violetta",
        w: "Wanda",
        x: "Xenia",
        y: "Yvona",
        z: "Zuzanna",
      };

      const DIGIT_NAMES_PL = {
        0: "zero",
        1: "jeden",
        2: "dwa",
        3: "trzy",
        4: "cztery",
        5: "piƒôƒá",
        6: "sze≈õƒá",
        7: "siedem",
        8: "osiem",
        9: "dziewiƒôƒá",
      };

      const stripDiacritics = (value) => {
        // Mapowanie polskich znak√≥w, kt√≥re nie dekomponujƒÖ siƒô w NFD
        const polishMap = {
          '≈Ç': 'l', '≈Å': 'L',
          'ƒÖ': 'a', 'ƒÑ': 'A',
          'ƒô': 'e', 'ƒò': 'E',
          '√≥': 'o', '√ì': 'O',
          '≈õ': 's', '≈ö': 'S',
          '≈∫': 'z', '≈π': 'Z',
          '≈º': 'z', '≈ª': 'Z',
          'ƒá': 'c', 'ƒÜ': 'C',
          '≈Ñ': 'n', '≈É': 'N',
        };
        
        let result = value;
        for (const [pl, ascii] of Object.entries(polishMap)) {
          result = result.replaceAll(pl, ascii);
        }
        // Usu≈Ñ pozosta≈Çe znaki diakrytyczne z innych jƒôzyk√≥w
        return result.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      };

      const transcribePassword = (value) => {
        const normalized = stripDiacritics(value);
        const parts = [];

        for (let i = 0; i < normalized.length; i += 1) {
          const originalChar = value[i];
          const ch = normalized[i];
          const lower = ch.toLowerCase();

          if (ICAO_PL[lower]) {
            const isUpper = originalChar === originalChar.toUpperCase();
            const sizeLabel = isUpper ? "du≈ºa" : "ma≈Ça";
            parts.push(`${sizeLabel} ${ICAO_PL[lower]}`);
          } else if (DIGIT_NAMES_PL[lower]) {
            parts.push(`cyfra ${DIGIT_NAMES_PL[lower]}`);
          } else {
            parts.push(`znak ${ch}`);
          }
        }

        return parts.join(" | ");
      };

      const ensureDigitAndSpecial = (value) => {
        let result = value;
        const hasDigit = /\d/.test(result);
        const hasSpecial = Array.from(result).some((char) =>
          SPECIALS.includes(char)
        );

        if (!hasDigit) {
          result += randomItem(DIGITS);
        }

        if (!hasSpecial) {
          result += randomItem(SPECIALS);
        }

        return result;
      };

      const variants = [
        { key: "ascii", min: 28, max: 36, strip: true, minWords: 4, titleBase: "Has≈Ço dobre (bez polskich diakrytycznych)" },
        { key: "long", min: 24, max: 32, strip: false, minWords: 3, titleBase: "Has≈Ço d≈Çugie" },
        { key: "ascii-short", min: 20, max: 26, strip: true, minWords: 3, titleBase: "Has≈Ço kr√≥tkie (bez polskich diakrytycznych)" },
        { key: "medium", min: 13, max: 16, strip: false, minWords: 2, titleBase: "Has≈Ço ≈õrednie" },
      ];

      const getElementsFor = (key) => ({
        title: document.getElementById(`title-${key}`),
        password: document.getElementById(`password-${key}`),
        transcription: document.getElementById(`transcription-${key}`),
        sentence: document.getElementById(`sentence-${key}`),
        copy: document.querySelector(`.copy-btn[data-copy="${key}"]`),
      });

      // Buduje has≈Ço z bezpo≈õrednio nastƒôpujƒÖcych po sobie s≈Ç√≥w z jednej linii
      // lines to tablica linii (zda≈Ñ)
      // Zwraca obiekt { password, sentence } lub null
      const buildPassword = (minLength, maxLength, strip, minWords = 2, lines = []) => {
        if (lines.length === 0) return null;

        for (let attempt = 0; attempt < MAX_PASSWORD_ATTEMPTS; attempt += 1) {
          // Wybierz losowƒÖ liniƒô
          const line = randomItem(lines);
          const lineWords = extractWordsFromLine(line);

          if (lineWords.length < minWords) continue;

          // Losuj liczbƒô s≈Ç√≥w od minWords do minWords+2, ale nie wiƒôcej ni≈º dostƒôpne
          const maxWordCount = Math.min(lineWords.length, minWords + 2);
          const wordCount = Math.floor(Math.random() * (maxWordCount - minWords + 1)) + minWords;

          // Wybierz losowy punkt startowy dla ciƒÖgu s≈Ç√≥w
          const maxStartIndex = lineWords.length - wordCount;
          const startIndex = Math.floor(Math.random() * (maxStartIndex + 1));

          // We≈∫ ciƒÖg nastƒôpujƒÖcych po sobie s≈Ç√≥w
          const selectedWords = lineWords.slice(startIndex, startIndex + wordCount);

          // Sprawd≈∫ czy kt√≥re≈õ s≈Çowo nie jest wykluczone
          const hasExcluded = selectedWords.some(word => isWordExcluded(word));
          if (hasExcluded) continue;

          const separators = Array.from({ length: wordCount - 1 }, () => {
            const useDigit = Math.random() < 0.5;
            return useDigit ? randomItem(DIGITS) : randomItem(SPECIALS);
          });

          const cases = Array(selectedWords.length).fill(null);
          const lowerIndex = Math.floor(Math.random() * selectedWords.length);
          let upperIndex = Math.floor(Math.random() * selectedWords.length);
          while (upperIndex === lowerIndex) {
            upperIndex = Math.floor(Math.random() * selectedWords.length);
          }
          cases[lowerIndex] = "lower";
          cases[upperIndex] = "upper";

          const parts = selectedWords.map((word, index) =>
            normalizeWord(word, cases[index])
          );
          let password = parts[0];
          for (let i = 0; i < separators.length; i += 1) {
            password += `${separators[i]}${parts[i + 1]}`;
          }

          if (strip) {
            password = stripDiacritics(password);
          }

          password = ensureDigitAndSpecial(password);

          if (password.length >= minLength && password.length <= maxLength) {
            // Wyklucz u≈ºyte s≈Çowa na przysz≈Ço≈õƒá
            excludeWords(selectedWords);
            return { password, sentence: line };
          }
        }

        return null;
      };

      const generatePasswords = async () => {
        if (SOURCE_FILES.length === 0) {
          variants.forEach(({ key, titleBase }) => {
            const elements = getElementsFor(key);
            elements.title.textContent = titleBase;
            elements.password.textContent = "Brak plik√≥w ≈∫r√≥d≈Çowych.";
            elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
            elements.sentence.textContent = "Zdanie: ‚Äî";
            elements.copy.disabled = true;
          });
          return;
        }

        // Dla ka≈ºdego wariantu losuj osobny plik i generuj has≈Ço
        for (const { key, min, max, strip, minWords, titleBase } of variants) {
          const elements = getElementsFor(key);

          try {
            // Wybierz losowy plik dla tego has≈Ça
            const randomFile = randomItem(SOURCE_FILES);

            // Za≈Çaduj linie z wybranego pliku
            const lines = await loadLinesFromFile(randomFile);

            if (lines.length === 0) {
              elements.title.textContent = titleBase;
              elements.password.textContent = "Za ma≈Ço zda≈Ñ do losowania.";
              elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
              elements.sentence.textContent = "Zdanie: ‚Äî";
              elements.copy.disabled = true;
              continue;
            }

            const result = buildPassword(min, max, strip, minWords, lines);

            if (!result) {
              elements.title.textContent = titleBase;
              elements.password.textContent = "Nie uda≈Ço siƒô wygenerowaƒá has≈Ça w tym zakresie.";
              elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
              elements.sentence.textContent = "Zdanie: ‚Äî";
              elements.copy.disabled = true;
              continue;
            }

            elements.title.textContent = `${titleBase}, ${result.password.length} znak√≥w`;
            elements.password.textContent = result.password;
            elements.transcription.textContent = transcribePassword(result.password);
            elements.sentence.textContent = `Zdanie: ‚Äû${result.sentence}"`;
            elements.copy.disabled = false;
          } catch (error) {
            elements.title.textContent = titleBase;
            elements.password.textContent = "B≈ÇƒÖd wczytywania pliku ≈∫r√≥d≈Çowego";
            elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
            elements.sentence.textContent = "Zdanie: ‚Äî";
            elements.copy.disabled = true;
          }
        }
      };

      const copyPassword = async (key) => {
        const elements = getElementsFor(key);
        const text = elements.password.textContent?.trim();
        if (!text || text === "≈Åadowanie‚Ä¶") return;

        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.setAttribute("readonly", "");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
          }

          const previous = elements.copy.textContent;
          elements.copy.textContent = "Skopiowano!";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        } catch {
          const previous = elements.copy.textContent;
          elements.copy.textContent = "Nie uda≈Ço siƒô";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        }
      };

      // Sprawdza, czy linijka spe≈Çnia minimalne wymagania
      const isValidLine = (line) => {
        const trimmed = line.trim();
        if (trimmed.length < MIN_CHARS_IN_LINE) return false;
        
        const wordsInLine = trimmed.split(/\s+/).filter(w => w.length > 0);
        return wordsInLine.length >= MIN_WORDS_IN_LINE;
      };

      // Wyodrƒôbnia s≈Çowa z linijki (bez znak√≥w interpunkcyjnych)
      const extractWordsFromLine = (line) => {
        return line
          .split(/\s+/)
          .map(word => removePunctuation(word).trim())
          .filter(word => word.length > 0);
      };

      // ≈Åaduje listƒô plik√≥w ≈∫r√≥d≈Çowych z sources.json
      const loadSourcesList = async () => {
        try {
          const response = await fetch('sources.json');
          if (!response.ok) {
            console.warn('Nie mo≈ºna za≈Çadowaƒá sources.json, u≈ºywam warto≈õci domy≈õlnych');
            // Fallback - warto≈õci domy≈õlne
            SOURCE_FILES = [
              "sources/ksiazka1.txt",
              "sources/ksiazka2.txt",
              "sources/ksiazka3.txt",
              "sources/ksiazka4.txt",
              "sources/ksiazka5.txt",
            ];
            return;
          }
          SOURCE_FILES = await response.json();
        } catch (error) {
          // Fallback - warto≈õci domy≈õlne
          SOURCE_FILES = [
            "sources/ksiazka1.txt",
            "sources/ksiazka2.txt",
            "sources/ksiazka3.txt",
            "sources/ksiazka4.txt",
            "sources/ksiazka5.txt",
          ];
        }
      };

      // ≈Åaduje linie z podanego pliku ≈∫r√≥d≈Çowego
      // Zwraca tablicƒô linii spe≈ÇniajƒÖcych wymagania
      const loadLinesFromFile = async (filePath) => {
        const response = await fetch(filePath);
        if (!response.ok) throw new Error(`Nie uda≈Ço siƒô wczytaƒá pliku: ${filePath}`);

        const text = await response.text();
        const lines = text.split(/\r?\n/);

        // Filtruj linijki spe≈ÇniajƒÖce wymagania
        const validLines = lines.filter(isValidLine).map(line => line.trim());

        if (validLines.length === 0) {
          throw new Error("Brak linijek spe≈ÇniajƒÖcych wymagania.");
        }

        return validLines;
      };

      const exclusionStatsEl = document.getElementById("exclusion-stats");
      const clearExclusionsBtn = document.getElementById("clear-exclusions");

      // Aktualizuje wy≈õwietlanie statystyk wyklucze≈Ñ
      const updateExclusionStats = () => {
        const count = getExclusionStats();
        exclusionStatsEl.textContent = `Wykluczone s≈Çowa: ${count} (wygasajƒÖ po 31 dniach)`;
      };

      // Czy≈õci wszystkie wykluczenia
      clearExclusionsBtn.addEventListener("click", () => {
        localStorage.removeItem(EXCLUSION_STORAGE_KEY);
        updateExclusionStats();
        clearExclusionsBtn.textContent = "Wyczyszczono!";
        setTimeout(() => {
          clearExclusionsBtn.textContent = "Wyczy≈õƒá historiƒô";
        }, 1200);
      });

      regenBtn.addEventListener("click", async () => {
        // Poka≈º wizualny feedback ≈Çadowania
        regenBtn.classList.add("loading");
        regenBtn.disabled = true;

        try {
          // Generuj has≈Ça (ka≈ºde z innego pliku)
          await generatePasswords();
          updateExclusionStats();
        } finally {
          // Usu≈Ñ wizualny feedback
          regenBtn.classList.remove("loading");
          regenBtn.disabled = false;
        }
      });
      copyButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const key = button.dataset.copy;
          if (key) copyPassword(key);
        });
      });

      // === Tryb API ===
      // Generuje has≈Ça i zwraca JSON (bez interfejsu)
      const generateApiResponse = async () => {
        document.body.innerHTML = '';
        document.body.style.background = 'none';
        document.body.style.fontFamily = 'monospace';
        document.body.style.whiteSpace = 'pre-wrap';
        document.body.style.padding = '20px';

        try {
          await loadSourcesList();

          if (SOURCE_FILES.length === 0) {
            document.body.textContent = JSON.stringify({ error: "Brak plik√≥w ≈∫r√≥d≈Çowych" }, null, 2);
            return;
          }

          const passwords = {};

          for (const { key, min, max, strip, minWords, titleBase } of variants) {
            try {
              const randomFile = randomItem(SOURCE_FILES);
              const lines = await loadLinesFromFile(randomFile);

              if (lines.length === 0) {
                passwords[key] = { error: "Za ma≈Ço zda≈Ñ do losowania" };
                continue;
              }

              const result = buildPassword(min, max, strip, minWords, lines);

              if (!result) {
                passwords[key] = { error: "Nie uda≈Ço siƒô wygenerowaƒá has≈Ça" };
                continue;
              }

              passwords[key] = {
                name: titleBase,
                password: result.password,
                length: result.password.length,
                sentence: result.sentence,
                transcription: transcribePassword(result.password)
              };
            } catch (error) {
              passwords[key] = { error: "B≈ÇƒÖd generowania" };
            }
          }

          const response = {
            generated: new Date().toISOString(),
            passwords
          };

          document.body.textContent = JSON.stringify(response, null, 2);
        } catch (error) {
          document.body.textContent = JSON.stringify({ error: "B≈ÇƒÖd ≈Çadowania ≈∫r√≥de≈Ç" }, null, 2);
        }
      };

      // === Inicjalizacja ===
      if (isApiMode) {
        // Tryb API - zwr√≥ƒá JSON
        generateApiResponse();
      } else {
        // Tryb normalny - interfejs wizualny
        cleanExpiredExclusions();
        updateExclusionStats();

        loadSourcesList()
          .then(() => generatePasswords())
          .then(() => {
            updateExclusionStats();
          })
          .catch(() => {
            variants.forEach(({ key, titleBase }) => {
              const elements = getElementsFor(key);
              elements.title.textContent = titleBase;
              elements.password.textContent = "B≈ÇƒÖd wczytywania plik√≥w z katalogu sources/";
              elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
              elements.sentence.textContent = "Zdanie: ‚Äî";
              elements.copy.disabled = true;
            });
          });
      }
    </script>
  </body>
</html>
