<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generator haseł</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(1000px 600px at 10% 10%, #e9f2ff 0%, #f7f7f7 45%, #ffffff 100%);
        color: #111;
      }
      .card {
        width: min(720px, 92vw);
        padding: 32px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
        display: grid;
        gap: 16px;
      }
      .password-grid {
        display: grid;
        gap: 16px;
      }
      .password-card {
        padding: 16px;
        border-radius: 12px;
        border: 1px solid #d7e0ff;
        background: #f8faff;
        display: grid;
        gap: 12px;
      }
      h1 {
        margin: 0;
        font-size: 24px;
      }
      h2 {
        margin: 0;
        font-size: 18px;
      }
      .password {
        font-size: clamp(20px, 3vw, 30px);
        font-weight: 700;
        letter-spacing: 0.5px;
        word-break: break-word;
        padding: 16px;
        border-radius: 12px;
        background: #f1f5ff;
        border: 1px solid #d7e0ff;
      }
      .transcription {
        font-size: clamp(14px, 2vw, 18px);
        font-weight: 600;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      button {
        border: 0;
        padding: 10px 16px;
        border-radius: 10px;
        background: #3b6ef5;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #2f5fe0;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .muted {
        color: #666;
        font-size: 14px;
      }
      .footer {
        font-size: 13px;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: radial-gradient(1000px 600px at 10% 10%, #1b2433 0%, #0f1117 50%, #0b0d12 100%);
          color: #f5f5f5;
        }
        .card {
          background: rgba(18, 20, 26, 0.9);
          box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        }
        .password-card {
          background: #121821;
          border-color: #25314b;
        }
        .password {
          background: #141a24;
          border-color: #25314b;
        }
        .muted {
          color: #aab0bb;
        }
      }
    </style>
  </head>
  <body>
    <main class="card">
      <h1>Generator haseł</h1>
      <p class="muted">Cztery propozycje haseł o różnych długościach. Każda propozycja ma własną transkrypcję.</p>
      <details class="muted" style="font-size: 13px; cursor: pointer;">
        <summary>Źródła słów (książki)</summary>
        <ul style="margin: 8px 0 0 0; padding-left: 20px;">
          <li>Joseph Conrad — „Tajny Agent"</li>
          <li>Arthur Conan Doyle — „Człowiek z blizną"</li>
          <li>Eliza Orzeszkowa — „Nad Niemnem" (tom I–III)</li>
        </ul>
        <p style="margin: 8px 0 0 0;">Teksty pochodzą z <a href="https://wolnelektury.pl" target="_blank" rel="noopener">WolneLektury.pl</a>.</p>
      </details>
      <div class="password-grid">
        <section class="password-card" aria-live="polite">
          <h2>Hasło dobre (bez polskich diakrytycznych)</h2>
          <div id="password-ascii" class="password">Ładowanie…</div>
          <div id="transcription-ascii" class="password transcription">Transkrypcja…</div>
          <div id="length-ascii" class="muted">Długość hasła: —</div>
          <div id="source-ascii" class="muted">Źródło: —</div>
          <button class="copy-btn" type="button" data-copy="ascii" disabled>Skopiuj hasło</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2>Hasło krótkie</h2>
          <div id="password-short" class="password">Ładowanie…</div>
          <div id="transcription-short" class="password transcription">Transkrypcja…</div>
          <div id="length-short" class="muted">Długość hasła: —</div>
          <div id="source-short" class="muted">Źródło: —</div>
          <button class="copy-btn" type="button" data-copy="short" disabled>Skopiuj hasło</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2>Hasło średnie</h2>
          <div id="password-medium" class="password">Ładowanie…</div>
          <div id="transcription-medium" class="password transcription">Transkrypcja…</div>
          <div id="length-medium" class="muted">Długość hasła: —</div>
          <div id="source-medium" class="muted">Źródło: —</div>
          <button class="copy-btn" type="button" data-copy="medium" disabled>Skopiuj hasło</button>
        </section>
        <section class="password-card" aria-live="polite" >
          <h2>Hasło długie</h2>
          <div id="password-long" class="password">Ładowanie…</div>
          <div id="transcription-long" class="password transcription">Transkrypcja…</div>
          <div id="length-long" class="muted">Długość hasła: —</div>
          <div id="source-long" class="muted">Źródło: —</div>
          <button class="copy-btn" type="button" data-copy="long" disabled>Skopiuj hasło</button>
        </section>
      </div>
      <div class="row">
        <button id="regen" type="button">Wygeneruj ponownie</button>
        <button id="clear-exclusions" type="button" style="background: #666;">Wyczyść historię</button>
        <span class="muted">Hasła zawierają cyfrę oraz znak specjalny.</span>
      </div>
      <div class="row">
        <span id="exclusion-stats" class="muted">Wykluczone słowa: 0</span>
      </div>
      <footer class="muted footer">
        Strona nie przechowuje wygenerowanych haseł. Repozytorium:
        <a href="https://github.com/enclude/www.hasla.zjawa.it" target="_blank" rel="noopener noreferrer">github.com/enclude/www.hasla.zjawa.it</a>.
        Licencja: CC BY 4.0 — wymagane wskazanie źródła i twórcy.
      </footer>
    </main>

    <script>
      // Lista plików źródłowych - ładowana dynamicznie z sources.json
      let SOURCE_FILES = [];
      
      const DIGITS = "0123456789";
      const SPECIALS = "!@#$%^&*()-_=+[]{};:,.?/|";
      
      // Minimalne wymagania dla linijki
      const MIN_WORDS_IN_LINE = 5;
      const MIN_CHARS_IN_LINE = 24;
      
      // Mechanizm wykluczeń - użyte słowa są wykluczane na określony czas
      const EXCLUSION_STORAGE_KEY = "hasla_excluded_words";
      const EXCLUSION_TIME_MS = 24 * 60 * 60 * 1000 * 31; // 31 dni
      const MAX_EXCLUDED_WORDS = 1500; // Maksymalna liczba wykluczonych słów

      const regenBtn = document.getElementById("regen");
      const copyButtons = Array.from(document.querySelectorAll(".copy-btn"));

      let words = [];
      let currentSourceFile = "";

      const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

      // === Mechanizm wykluczeń ===
      
      // Pobiera listę wykluczonych słów z localStorage
      const getExcludedWords = () => {
        try {
          const data = localStorage.getItem(EXCLUSION_STORAGE_KEY);
          if (!data) return {};
          return JSON.parse(data);
        } catch {
          return {};
        }
      };

      // Zapisuje listę wykluczonych słów do localStorage
      const saveExcludedWords = (excluded) => {
        try {
          localStorage.setItem(EXCLUSION_STORAGE_KEY, JSON.stringify(excluded));
        } catch {
          // localStorage może być pełny lub niedostępny
          console.warn("Nie udało się zapisać wykluczeń do localStorage");
        }
      };

      // Czyści przeterminowane wykluczenia
      const cleanExpiredExclusions = () => {
        const excluded = getExcludedWords();
        const now = Date.now();
        let cleaned = false;
        
        for (const [word, timestamp] of Object.entries(excluded)) {
          if (now - timestamp > EXCLUSION_TIME_MS) {
            delete excluded[word];
            cleaned = true;
          }
        }
        
        if (cleaned) {
          saveExcludedWords(excluded);
        }
        
        return excluded;
      };

      // Dodaje słowa do listy wykluczeń
      const excludeWords = (wordsToExclude) => {
        const excluded = cleanExpiredExclusions();
        const now = Date.now();
        
        for (const word of wordsToExclude) {
          const normalizedWord = word.toLowerCase();
          excluded[normalizedWord] = now;
        }
        
        // Ogranicz rozmiar listy wykluczeń
        const entries = Object.entries(excluded);
        if (entries.length > MAX_EXCLUDED_WORDS) {
          // Usuń najstarsze wpisy
          entries.sort((a, b) => a[1] - b[1]);
          const toKeep = entries.slice(-MAX_EXCLUDED_WORDS);
          const newExcluded = Object.fromEntries(toKeep);
          saveExcludedWords(newExcluded);
        } else {
          saveExcludedWords(excluded);
        }
      };

      // Sprawdza, czy słowo jest wykluczone
      const isWordExcluded = (word) => {
        const excluded = getExcludedWords();
        const normalizedWord = word.toLowerCase();
        const timestamp = excluded[normalizedWord];
        
        if (!timestamp) return false;
        
        // Sprawdź, czy wykluczenie nie wygasło
        return (Date.now() - timestamp) <= EXCLUSION_TIME_MS;
      };

      // Filtruje słowa, usuwając wykluczone
      const filterExcludedWords = (wordList) => {
        cleanExpiredExclusions();
        return wordList.filter(word => !isWordExcluded(word));
      };

      // Zwraca statystyki wykluczeń
      const getExclusionStats = () => {
        const excluded = cleanExpiredExclusions();
        return Object.keys(excluded).length;
      };

      // === Koniec mechanizmu wykluczeń ===

      // Usuwa znaki interpunkcyjne ze słowa
      const removePunctuation = (text) => 
        text.replace(/[.,;:!?„""''«»()[\]{}<>—–\-\/\\…'"]/g, "");

      const normalizeWord = (word, forceCase) => {
        if (forceCase === "lower") return word.toLowerCase();
        if (forceCase === "upper") return word.toUpperCase();
        return Math.random() < 0.5 ? word.toLowerCase() : word.toUpperCase();
      };

      const ICAO_PL = {
        a: "Adam",
        b: "Barbara",
        c: "Celina",
        d: "Dorota",
        e: "Ewa",
        f: "Franciszek",
        g: "Genowefa",
        h: "Henryk",
        i: "Irena",
        j: "Józef",
        k: "Karol",
        l: "Leon",
        m: "Maria",
        n: "Natalia",
        o: "Olga",
        p: "Paweł",
        q: "Quiryn",
        r: "Roman",
        s: "Stefan",
        t: "Tadeusz",
        u: "Urszula",
        v: "Violetta",
        w: "Wanda",
        x: "Xawery",
        y: "Yvonne",
        z: "Zenon",
      };

      const DIGIT_NAMES_PL = {
        0: "zero",
        1: "jeden",
        2: "dwa",
        3: "trzy",
        4: "cztery",
        5: "pięć",
        6: "sześć",
        7: "siedem",
        8: "osiem",
        9: "dziewięć",
      };

      const stripDiacritics = (value) => {
        // Mapowanie polskich znaków, które nie dekomponują się w NFD
        const polishMap = {
          'ł': 'l', 'Ł': 'L',
          'ą': 'a', 'Ą': 'A',
          'ę': 'e', 'Ę': 'E',
          'ó': 'o', 'Ó': 'O',
          'ś': 's', 'Ś': 'S',
          'ź': 'z', 'Ź': 'Z',
          'ż': 'z', 'Ż': 'Z',
          'ć': 'c', 'Ć': 'C',
          'ń': 'n', 'Ń': 'N',
        };
        
        let result = value;
        for (const [pl, ascii] of Object.entries(polishMap)) {
          result = result.replaceAll(pl, ascii);
        }
        // Usuń pozostałe znaki diakrytyczne z innych języków
        return result.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      };

      const transcribePassword = (value) => {
        const normalized = stripDiacritics(value);
        const parts = [];

        for (let i = 0; i < normalized.length; i += 1) {
          const originalChar = value[i];
          const ch = normalized[i];
          const lower = ch.toLowerCase();

          if (ICAO_PL[lower]) {
            const isUpper = originalChar === originalChar.toUpperCase();
            const sizeLabel = isUpper ? "duża" : "mała";
            parts.push(`${sizeLabel} ${ICAO_PL[lower]}`);
          } else if (DIGIT_NAMES_PL[lower]) {
            parts.push(`cyfra ${DIGIT_NAMES_PL[lower]}`);
          } else {
            parts.push(`znak ${ch}`);
          }
        }

        return parts.join(" | ");
      };

      const ensureDigitAndSpecial = (value) => {
        let result = value;
        const hasDigit = /\d/.test(result);
        const hasSpecial = Array.from(result).some((char) =>
          SPECIALS.includes(char)
        );

        if (!hasDigit) {
          result += randomItem(DIGITS);
        }

        if (!hasSpecial) {
          result += randomItem(SPECIALS);
        }

        return result;
      };

      const variants = [
        { key: "short", min: 8, max: 12, strip: false, minWords: 2 },
        { key: "medium", min: 13, max: 16, strip: false, minWords: 2 },
        { key: "long", min: 17, max: 24, strip: false, minWords: 2 },
        { key: "ascii", min: 18, max: 26, strip: true, minWords: 3 },
      ];

      const getElementsFor = (key) => ({
        password: document.getElementById(`password-${key}`),
        transcription: document.getElementById(`transcription-${key}`),
        length: document.getElementById(`length-${key}`),
        source: document.getElementById(`source-${key}`),
        copy: document.querySelector(`.copy-btn[data-copy="${key}"]`),
      });

      const buildPassword = (minLength, maxLength, strip, minWords = 2) => {
        // Filtruj wykluczone słowa
        const availableWords = filterExcludedWords(words);
        
        if (availableWords.length < minWords) {
          // Jeśli za mało słów po filtracji, użyj wszystkich (ignoruj wykluczenia)
          if (words.length < minWords) return null;
          console.log("Za mało dostępnych słów, ignoruję wykluczenia");
        }
        
        const wordPool = availableWords.length >= minWords ? availableWords : words;

        const attempts = 200;
        for (let attempt = 0; attempt < attempts; attempt += 1) {
          // Losuj liczbę słów od minWords do minWords+2
          const wordCount = Math.min(
            wordPool.length,
            Math.floor(Math.random() * 3) + minWords
          );
          
          // Wybierz losowe słowa z puli
          const pool = [...wordPool];
          const selected = [];
          for (let i = 0; i < wordCount; i += 1) {
            const index = Math.floor(Math.random() * pool.length);
            selected.push(pool.splice(index, 1)[0]);
          }

          const separators = Array.from({ length: wordCount - 1 }, () => {
            const useDigit = Math.random() < 0.5;
            return useDigit ? randomItem(DIGITS) : randomItem(SPECIALS);
          });

          const cases = Array(selected.length).fill(null);
          const lowerIndex = Math.floor(Math.random() * selected.length);
          let upperIndex = Math.floor(Math.random() * selected.length);
          while (upperIndex === lowerIndex) {
            upperIndex = Math.floor(Math.random() * selected.length);
          }
          cases[lowerIndex] = "lower";
          cases[upperIndex] = "upper";

          const parts = selected.map((word, index) =>
            normalizeWord(word, cases[index])
          );
          let password = parts[0];
          for (let i = 0; i < separators.length; i += 1) {
            password += `${separators[i]}${parts[i + 1]}`;
          }

          if (strip) {
            password = stripDiacritics(password);
          }

          password = ensureDigitAndSpecial(password);

          if (password.length >= minLength && password.length <= maxLength) {
            // Wyklucz użyte słowa na przyszłość
            excludeWords(selected);
            return password;
          }
        }

        return null;
      };

      const generatePasswords = () => {
        if (!words.length) {
          variants.forEach(({ key }) => {
            const elements = getElementsFor(key);
            elements.password.textContent = "Brak słów do losowania.";
            elements.transcription.textContent = "Transkrypcja niedostępna.";
            elements.length.textContent = "Długość hasła: —";
            elements.source.textContent = "Źródło: —";
            elements.copy.disabled = true;
          });
          return;
        }

        if (words.length < 2) {
          variants.forEach(({ key }) => {
            const elements = getElementsFor(key);
            elements.password.textContent = "Za mało słów do losowania.";
            elements.transcription.textContent = "Transkrypcja niedostępna.";
            elements.length.textContent = "Długość hasła: —";
            elements.source.textContent = "Źródło: —";
            elements.copy.disabled = true;
          });
          return;
        }

        // Wyodrębnij nazwę pliku z pełnej ścieżki
        const sourceFileName = currentSourceFile.split('/').pop();

        variants.forEach(({ key, min, max, strip, minWords }) => {
          const elements = getElementsFor(key);
          const password = buildPassword(min, max, strip, minWords);

          if (!password) {
            elements.password.textContent = "Nie udało się wygenerować hasła w tym zakresie.";
            elements.transcription.textContent = "Transkrypcja niedostępna.";
            elements.length.textContent = "Długość hasła: —";
            elements.source.textContent = "Źródło: —";
            elements.copy.disabled = true;
            return;
          }

          elements.password.textContent = password;
          elements.transcription.textContent = transcribePassword(password);
          elements.length.textContent = `Długość hasła: ${password.length} znaków`;
          elements.source.textContent = `Źródło: ${sourceFileName}`;
          elements.copy.disabled = false;
        });
      };

      const copyPassword = async (key) => {
        const elements = getElementsFor(key);
        const text = elements.password.textContent?.trim();
        if (!text || text === "Ładowanie…") return;

        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.setAttribute("readonly", "");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
          }

          const previous = elements.copy.textContent;
          elements.copy.textContent = "Skopiowano!";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        } catch {
          const previous = elements.copy.textContent;
          elements.copy.textContent = "Nie udało się";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        }
      };

      // Sprawdza, czy linijka spełnia minimalne wymagania
      const isValidLine = (line) => {
        const trimmed = line.trim();
        if (trimmed.length < MIN_CHARS_IN_LINE) return false;
        
        const wordsInLine = trimmed.split(/\s+/).filter(w => w.length > 0);
        return wordsInLine.length >= MIN_WORDS_IN_LINE;
      };

      // Wyodrębnia słowa z linijki (bez znaków interpunkcyjnych)
      const extractWordsFromLine = (line) => {
        return line
          .split(/\s+/)
          .map(word => removePunctuation(word).trim())
          .filter(word => word.length > 0);
      };

      // Pobiera losowy ciąg następujących po sobie słów z linijki
      const getConsecutiveWords = (line, count) => {
        const lineWords = extractWordsFromLine(line);
        if (lineWords.length < count) return lineWords;
        
        const maxStartIndex = lineWords.length - count;
        const startIndex = Math.floor(Math.random() * (maxStartIndex + 1));
        return lineWords.slice(startIndex, startIndex + count);
      };

      // Ładuje listę plików źródłowych z sources.json
      const loadSourcesList = async () => {
        try {
          const response = await fetch('sources.json', { cache: "no-store" });
          if (!response.ok) {
            console.warn('Nie można załadować sources.json, używam wartości domyślnych');
            // Fallback - wartości domyślne
            SOURCE_FILES = [
              "sources/ksiazka1.txt",
              "sources/ksiazka2.txt",
              "sources/ksiazka3.txt",
              "sources/ksiazka4.txt",
              "sources/ksiazka5.txt",
            ];
            return;
          }
          SOURCE_FILES = await response.json();
          console.log(`Załadowano ${SOURCE_FILES.length} plików źródłowych z sources.json`);
        } catch (error) {
          console.error('Błąd ładowania sources.json:', error);
          // Fallback - wartości domyślne
          SOURCE_FILES = [
            "sources/ksiazka1.txt",
            "sources/ksiazka2.txt",
            "sources/ksiazka3.txt",
            "sources/ksiazka4.txt",
            "sources/ksiazka5.txt",
          ];
        }
      };

      // Ładuje słowa z losowego pliku źródłowego
      const loadWords = async () => {
        // Wybierz losowy plik źródłowy
        const randomFile = randomItem(SOURCE_FILES);
        currentSourceFile = randomFile;
        console.log(`Ładowanie słów z pliku: ${randomFile}`);
        
        const response = await fetch(randomFile, { cache: "no-store" });
        if (!response.ok) throw new Error(`Nie udało się wczytać pliku: ${randomFile}`);

        const text = await response.text();
        const lines = text.split(/\r?\n/);
        
        // Filtruj linijki spełniające wymagania
        const validLines = lines.filter(isValidLine);
        
        if (validLines.length === 0) {
          throw new Error("Brak linijek spełniających wymagania.");
        }
        
        // Zbierz słowa z losowych linijek i losowych ciągów słów
        words = [];
        const linesToUse = Math.min(validLines.length, 50); // Użyj max 50 losowych linijek
        
        for (let i = 0; i < linesToUse; i++) {
          const randomLine = randomItem(validLines);
          // Losuj od 1 do 3 następujących po sobie słów z linijki
          const wordCount = Math.floor(Math.random() * 3) + 1;
          const consecutiveWords = getConsecutiveWords(randomLine, wordCount);
          words.push(...consecutiveWords);
        }
        
        // Usuń duplikaty i puste wartości
        words = [...new Set(words)].filter(w => w.length > 1);
        
        console.log(`Załadowano ${words.length} unikalnych słów`);
      };

      const exclusionStatsEl = document.getElementById("exclusion-stats");
      const clearExclusionsBtn = document.getElementById("clear-exclusions");

      // Aktualizuje wyświetlanie statystyk wykluczeń
      const updateExclusionStats = () => {
        const count = getExclusionStats();
        exclusionStatsEl.textContent = `Wykluczone słowa: ${count} (wygasają po 24h)`;
      };

      // Czyści wszystkie wykluczenia
      clearExclusionsBtn.addEventListener("click", () => {
        localStorage.removeItem(EXCLUSION_STORAGE_KEY);
        updateExclusionStats();
        clearExclusionsBtn.textContent = "Wyczyszczono!";
        setTimeout(() => {
          clearExclusionsBtn.textContent = "Wyczyść historię";
        }, 1200);
      });

      regenBtn.addEventListener("click", () => {
        // Przy każdym generowaniu wczytuj słowa z losowego pliku
        loadWords()
          .then(() => {
            generatePasswords();
            updateExclusionStats();
          })
          .catch(() => {
            variants.forEach(({ key }) => {
              const elements = getElementsFor(key);
              elements.password.textContent = "Błąd wczytywania pliku źródłowego";
              elements.transcription.textContent = "Transkrypcja niedostępna.";
              elements.length.textContent = "Długość hasła: —";
              elements.source.textContent = "Źródło: —";
              elements.copy.disabled = true;
            });
          });
      });
      copyButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const key = button.dataset.copy;
          if (key) copyPassword(key);
        });
      });

      // Wyczyść przeterminowane wykluczenia przy starcie
      cleanExpiredExclusions();
      updateExclusionStats();

      // Najpierw załaduj listę źródeł, potem słowa
      loadSourcesList()
        .then(() => loadWords())
        .then(() => {
          generatePasswords();
          updateExclusionStats();
        })
        .catch(() => {
          variants.forEach(({ key }) => {
            const elements = getElementsFor(key);
            elements.password.textContent = "Błąd wczytywania plików z katalogu sources/";
            elements.transcription.textContent = "Transkrypcja niedostępna.";
            elements.length.textContent = "Długość hasła: —";
            elements.source.textContent = "Źródło: —";
            elements.copy.disabled = true;
          });
        });
    </script>
  </body>
</html>
