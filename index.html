<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generator hase≈Ç</title>
    <meta name="description" content="Bezpieczny generator hase≈Ç oparty na literaturze polskiej. Generuje cztery warianty hase≈Ç o r√≥≈ºnych d≈Çugo≈õciach z transkrypcjƒÖ fonetycznƒÖ." />

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîê</text></svg>" />

    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:; connect-src 'self';" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(1000px 600px at 10% 10%, #e9f2ff 0%, #f7f7f7 45%, #ffffff 100%);
        color: #111;
      }
      .card {
        width: min(720px, 92vw);
        padding: 32px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
        display: grid;
        gap: 16px;
      }
      .password-grid {
        display: grid;
        gap: 16px;
      }
      .password-card {
        padding: 16px;
        border-radius: 12px;
        border: 1px solid #d7e0ff;
        background: #f8faff;
        display: grid;
        gap: 12px;
      }
      h1 {
        margin: 0;
        font-size: 24px;
      }
      h2 {
        margin: 0;
        font-size: 18px;
      }
      .password {
        font-size: clamp(20px, 3vw, 30px);
        font-weight: 700;
        letter-spacing: 0.5px;
        word-break: break-word;
        padding: 16px;
        border-radius: 12px;
        background: #f1f5ff;
        border: 1px solid #d7e0ff;
      }
      .transcription {
        font-size: clamp(14px, 2vw, 18px);
        font-weight: 600;
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      button {
        border: 0;
        padding: 10px 16px;
        border-radius: 10px;
        background: #3b6ef5;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #2f5fe0;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      button.loading {
        opacity: 0.7;
        cursor: wait;
      }
      button.loading::after {
        content: "...";
        animation: dots 1.5s steps(4, end) infinite;
      }
      @keyframes dots {
        0%, 20% { content: "."; }
        40% { content: ".."; }
        60%, 100% { content: "..."; }
      }
      .muted {
        color: #666;
        font-size: 14px;
      }
      .footer {
        font-size: 13px;
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: radial-gradient(1000px 600px at 10% 10%, #1b2433 0%, #0f1117 50%, #0b0d12 100%);
          color: #f5f5f5;
        }
        .card {
          background: rgba(18, 20, 26, 0.9);
          box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        }
        .password-card {
          background: #121821;
          border-color: #25314b;
        }
        .password {
          background: #141a24;
          border-color: #25314b;
        }
        .muted {
          color: #aab0bb;
        }
      }
    </style>
  </head>
  <body>
    <noscript>
      <div style="padding: 20px; text-align: center; background: #fff3cd; color: #856404; border: 1px solid #ffeeba; margin: 20px; border-radius: 8px;">
        <strong>JavaScript jest wymagany</strong><br>
        Ta aplikacja wymaga w≈ÇƒÖczonego JavaScript do dzia≈Çania. Proszƒô w≈ÇƒÖczyƒá JavaScript w przeglƒÖdarce.
      </div>
    </noscript>
    <main class="card">
      <h1>Generator hase≈Ç</h1>
      <p class="muted">Cztery propozycje hase≈Ç o r√≥≈ºnych d≈Çugo≈õciach. Ka≈ºda propozycja ma w≈ÇasnƒÖ transkrypcjƒô.</p>
      <details class="muted" style="font-size: 13px; cursor: pointer;">
        <p style="margin: 8px 0 0 0;">KsiƒÖ≈ºki pochodzƒÖ z <a href="https://wolnelektury.pl" target="_blank" rel="noopener">WolneLektury.pl</a>.</p>
      </details>
      <div class="password-grid">
        <section class="password-card" aria-live="polite">
          <h2>Has≈Ço dobre (bez polskich diakrytycznych)</h2>
          <div id="password-ascii" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-ascii" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="length-ascii" class="muted">D≈Çugo≈õƒá has≈Ça: ‚Äî</div>
          <div id="source-ascii" class="muted">≈πr√≥d≈Ço: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="ascii" disabled aria-label="Skopiuj has≈Ço dobre">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2>Has≈Ço kr√≥tkie</h2>
          <div id="password-short" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-short" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="length-short" class="muted">D≈Çugo≈õƒá has≈Ça: ‚Äî</div>
          <div id="source-short" class="muted">≈πr√≥d≈Ço: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="short" disabled aria-label="Skopiuj has≈Ço kr√≥tkie">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2>Has≈Ço ≈õrednie</h2>
          <div id="password-medium" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-medium" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="length-medium" class="muted">D≈Çugo≈õƒá has≈Ça: ‚Äî</div>
          <div id="source-medium" class="muted">≈πr√≥d≈Ço: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="medium" disabled aria-label="Skopiuj has≈Ço ≈õrednie">Skopiuj has≈Ço</button>
        </section>
        <section class="password-card" aria-live="polite">
          <h2>Has≈Ço d≈Çugie</h2>
          <div id="password-long" class="password">≈Åadowanie‚Ä¶</div>
          <div id="transcription-long" class="password transcription">Transkrypcja‚Ä¶</div>
          <div id="length-long" class="muted">D≈Çugo≈õƒá has≈Ça: ‚Äî</div>
          <div id="source-long" class="muted">≈πr√≥d≈Ço: ‚Äî</div>
          <button class="copy-btn" type="button" data-copy="long" disabled aria-label="Skopiuj has≈Ço d≈Çugie">Skopiuj has≈Ço</button>
        </section>
      </div>
      <div class="row">
        <button id="regen" type="button" aria-label="Wygeneruj nowe has≈Ça">Wygeneruj ponownie</button>
        <button id="clear-exclusions" type="button" style="background: #666;" aria-label="Wyczy≈õƒá historiƒô wykluczonych s≈Ç√≥w">Wyczy≈õƒá historiƒô</button>
        <span class="muted">Has≈Ça zawierajƒÖ cyfrƒô oraz znak specjalny.</span>
      </div>
      <div class="row">
        <span id="exclusion-stats" class="muted">Wykluczone s≈Çowa: 0</span>
      </div>
      <footer class="muted footer">
        Strona nie przechowuje wygenerowanych hase≈Ç. Repozytorium:
        <a href="https://github.com/enclude/www.hasla.zjawa.it" target="_blank" rel="noopener noreferrer">github.com/enclude/www.hasla.zjawa.it</a>.
        Licencja: CC BY 4.0 ‚Äî wymagane wskazanie ≈∫r√≥d≈Ça i tw√≥rcy.
      </footer>
    </main>

    <script>
      // Lista plik√≥w ≈∫r√≥d≈Çowych - ≈Çadowana dynamicznie z sources.json
      let SOURCE_FILES = [];
      
      const DIGITS = "0123456789";
      const SPECIALS = "!@#$%^&*()-_=+[]{};:,.?/|";
      
      // Minimalne wymagania dla linijki
      const MIN_WORDS_IN_LINE = 5;
      const MIN_CHARS_IN_LINE = 24;

      // Parametry generowania hase≈Ç
      const MAX_PASSWORD_ATTEMPTS = 200;
      const MAX_LINES_TO_USE = 50;
      
      // Mechanizm wyklucze≈Ñ - u≈ºyte s≈Çowa sƒÖ wykluczane na okre≈õlony czas
      const EXCLUSION_STORAGE_KEY = "hasla_excluded_words";
      const EXCLUSION_TIME_MS = 24 * 60 * 60 * 1000 * 31; // 31 dni
      const MAX_EXCLUDED_WORDS = 1500; // Maksymalna liczba wykluczonych s≈Ç√≥w

      const regenBtn = document.getElementById("regen");
      const copyButtons = Array.from(document.querySelectorAll(".copy-btn"));

      const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];

      // === Mechanizm wyklucze≈Ñ ===
      
      // Pobiera listƒô wykluczonych s≈Ç√≥w z localStorage
      const getExcludedWords = () => {
        try {
          const data = localStorage.getItem(EXCLUSION_STORAGE_KEY);
          if (!data) return {};
          return JSON.parse(data);
        } catch {
          return {};
        }
      };

      // Zapisuje listƒô wykluczonych s≈Ç√≥w do localStorage
      const saveExcludedWords = (excluded) => {
        try {
          localStorage.setItem(EXCLUSION_STORAGE_KEY, JSON.stringify(excluded));
        } catch {
          // localStorage mo≈ºe byƒá pe≈Çny lub niedostƒôpny
        }
      };

      // Czy≈õci przeterminowane wykluczenia
      const cleanExpiredExclusions = () => {
        const excluded = getExcludedWords();
        const now = Date.now();
        let cleaned = false;
        
        for (const [word, timestamp] of Object.entries(excluded)) {
          if (now - timestamp > EXCLUSION_TIME_MS) {
            delete excluded[word];
            cleaned = true;
          }
        }
        
        if (cleaned) {
          saveExcludedWords(excluded);
        }
        
        return excluded;
      };

      // Dodaje s≈Çowa do listy wyklucze≈Ñ
      const excludeWords = (wordsToExclude) => {
        const excluded = getExcludedWords();
        const now = Date.now();
        
        for (const word of wordsToExclude) {
          const normalizedWord = word.toLowerCase();
          excluded[normalizedWord] = now;
        }
        
        // Ogranicz rozmiar listy wyklucze≈Ñ
        const entries = Object.entries(excluded);
        if (entries.length > MAX_EXCLUDED_WORDS) {
          // Usu≈Ñ najstarsze wpisy
          entries.sort((a, b) => a[1] - b[1]);
          const toKeep = entries.slice(-MAX_EXCLUDED_WORDS);
          const newExcluded = Object.fromEntries(toKeep);
          saveExcludedWords(newExcluded);
        } else {
          saveExcludedWords(excluded);
        }
      };

      // Sprawdza, czy s≈Çowo jest wykluczone
      const isWordExcluded = (word) => {
        const excluded = getExcludedWords();
        const normalizedWord = word.toLowerCase();
        const timestamp = excluded[normalizedWord];
        
        if (!timestamp) return false;
        
        // Sprawd≈∫, czy wykluczenie nie wygas≈Ço
        return (Date.now() - timestamp) <= EXCLUSION_TIME_MS;
      };

      // Filtruje s≈Çowa, usuwajƒÖc wykluczone
      const filterExcludedWords = (wordList) => {
        return wordList.filter(word => !isWordExcluded(word));
      };

      // Zwraca statystyki wyklucze≈Ñ
      const getExclusionStats = () => {
        const excluded = cleanExpiredExclusions();
        return Object.keys(excluded).length;
      };

      // === Koniec mechanizmu wyklucze≈Ñ ===

      // Usuwa znaki interpunkcyjne ze s≈Çowa
      const removePunctuation = (text) => 
        text.replace(/[.,;:!?‚Äû""''¬´¬ª()[\]{}<>‚Äî‚Äì\-\/\\‚Ä¶'"]/g, "");

      const normalizeWord = (word, forceCase) => {
        if (forceCase === "lower") return word.toLowerCase();
        if (forceCase === "upper") return word.toUpperCase();
        return Math.random() < 0.5 ? word.toLowerCase() : word.toUpperCase();
      };

      const ICAO_PL = {
        a: "Adam",
        b: "Barbara",
        c: "Celina",
        d: "Dorota",
        e: "Ewa",
        f: "Franciszek",
        g: "Genowefa",
        h: "Henryk",
        i: "Irena",
        j: "J√≥zef",
        k: "Karol",
        l: "Leon",
        m: "Maria",
        n: "Natalia",
        o: "Olga",
        p: "Pawe≈Ç",
        q: "Quiryn",
        r: "Roman",
        s: "Stefan",
        t: "Tadeusz",
        u: "Urszula",
        v: "Violetta",
        w: "Wanda",
        x: "Xawery",
        y: "Yvonne",
        z: "Zenon",
      };

      const DIGIT_NAMES_PL = {
        0: "zero",
        1: "jeden",
        2: "dwa",
        3: "trzy",
        4: "cztery",
        5: "piƒôƒá",
        6: "sze≈õƒá",
        7: "siedem",
        8: "osiem",
        9: "dziewiƒôƒá",
      };

      const stripDiacritics = (value) => {
        // Mapowanie polskich znak√≥w, kt√≥re nie dekomponujƒÖ siƒô w NFD
        const polishMap = {
          '≈Ç': 'l', '≈Å': 'L',
          'ƒÖ': 'a', 'ƒÑ': 'A',
          'ƒô': 'e', 'ƒò': 'E',
          '√≥': 'o', '√ì': 'O',
          '≈õ': 's', '≈ö': 'S',
          '≈∫': 'z', '≈π': 'Z',
          '≈º': 'z', '≈ª': 'Z',
          'ƒá': 'c', 'ƒÜ': 'C',
          '≈Ñ': 'n', '≈É': 'N',
        };
        
        let result = value;
        for (const [pl, ascii] of Object.entries(polishMap)) {
          result = result.replaceAll(pl, ascii);
        }
        // Usu≈Ñ pozosta≈Çe znaki diakrytyczne z innych jƒôzyk√≥w
        return result.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      };

      const transcribePassword = (value) => {
        const normalized = stripDiacritics(value);
        const parts = [];

        for (let i = 0; i < normalized.length; i += 1) {
          const originalChar = value[i];
          const ch = normalized[i];
          const lower = ch.toLowerCase();

          if (ICAO_PL[lower]) {
            const isUpper = originalChar === originalChar.toUpperCase();
            const sizeLabel = isUpper ? "du≈ºa" : "ma≈Ça";
            parts.push(`${sizeLabel} ${ICAO_PL[lower]}`);
          } else if (DIGIT_NAMES_PL[lower]) {
            parts.push(`cyfra ${DIGIT_NAMES_PL[lower]}`);
          } else {
            parts.push(`znak ${ch}`);
          }
        }

        return parts.join(" | ");
      };

      const ensureDigitAndSpecial = (value) => {
        let result = value;
        const hasDigit = /\d/.test(result);
        const hasSpecial = Array.from(result).some((char) =>
          SPECIALS.includes(char)
        );

        if (!hasDigit) {
          result += randomItem(DIGITS);
        }

        if (!hasSpecial) {
          result += randomItem(SPECIALS);
        }

        return result;
      };

      const variants = [
        { key: "short", min: 8, max: 12, strip: false, minWords: 2 },
        { key: "medium", min: 13, max: 16, strip: false, minWords: 2 },
        { key: "long", min: 17, max: 24, strip: false, minWords: 2 },
        { key: "ascii", min: 18, max: 26, strip: true, minWords: 3 },
      ];

      const getElementsFor = (key) => ({
        password: document.getElementById(`password-${key}`),
        transcription: document.getElementById(`transcription-${key}`),
        length: document.getElementById(`length-${key}`),
        source: document.getElementById(`source-${key}`),
        copy: document.querySelector(`.copy-btn[data-copy="${key}"]`),
      });

      const buildPassword = (minLength, maxLength, strip, minWords = 2, wordList = words) => {
        // Filtruj wykluczone s≈Çowa
        const availableWords = filterExcludedWords(wordList);
        
        if (availableWords.length < minWords) {
          // Je≈õli za ma≈Ço s≈Ç√≥w po filtracji, u≈ºyj wszystkich (ignoruj wykluczenia)
          if (wordList.length < minWords) return null;
        }
        
        const wordPool = availableWords.length >= minWords ? availableWords : wordList;

        for (let attempt = 0; attempt < MAX_PASSWORD_ATTEMPTS; attempt += 1) {
          // Losuj liczbƒô s≈Ç√≥w od minWords do minWords+2
          const wordCount = Math.min(
            wordPool.length,
            Math.floor(Math.random() * 3) + minWords
          );
          
          // Wybierz losowe s≈Çowa z puli
          const pool = [...wordPool];
          const selected = [];
          for (let i = 0; i < wordCount; i += 1) {
            const index = Math.floor(Math.random() * pool.length);
            selected.push(pool.splice(index, 1)[0]);
          }

          const separators = Array.from({ length: wordCount - 1 }, () => {
            const useDigit = Math.random() < 0.5;
            return useDigit ? randomItem(DIGITS) : randomItem(SPECIALS);
          });

          const cases = Array(selected.length).fill(null);
          const lowerIndex = Math.floor(Math.random() * selected.length);
          let upperIndex = Math.floor(Math.random() * selected.length);
          while (upperIndex === lowerIndex) {
            upperIndex = Math.floor(Math.random() * selected.length);
          }
          cases[lowerIndex] = "lower";
          cases[upperIndex] = "upper";

          const parts = selected.map((word, index) =>
            normalizeWord(word, cases[index])
          );
          let password = parts[0];
          for (let i = 0; i < separators.length; i += 1) {
            password += `${separators[i]}${parts[i + 1]}`;
          }

          if (strip) {
            password = stripDiacritics(password);
          }

          password = ensureDigitAndSpecial(password);

          if (password.length >= minLength && password.length <= maxLength) {
            // Wyklucz u≈ºyte s≈Çowa na przysz≈Ço≈õƒá
            excludeWords(selected);
            return password;
          }
        }

        return null;
      };

      const generatePasswords = async () => {
        if (SOURCE_FILES.length === 0) {
          variants.forEach(({ key }) => {
            const elements = getElementsFor(key);
            elements.password.textContent = "Brak plik√≥w ≈∫r√≥d≈Çowych.";
            elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
            elements.length.textContent = "D≈Çugo≈õƒá has≈Ça: ‚Äî";
            elements.source.textContent = "≈πr√≥d≈Ço: ‚Äî";
            elements.copy.disabled = true;
          });
          return;
        }

        // Dla ka≈ºdego wariantu losuj osobny plik i generuj has≈Ço
        for (const { key, min, max, strip, minWords } of variants) {
          const elements = getElementsFor(key);
          
          try {
            // Wybierz losowy plik dla tego has≈Ça
            const randomFile = randomItem(SOURCE_FILES);
            const sourceFileName = randomFile.split('/').pop();

            // Za≈Çaduj s≈Çowa z wybranego pliku
            const wordList = await loadWordsFromFile(randomFile);
            
            if (wordList.length < minWords) {
              elements.password.textContent = "Za ma≈Ço s≈Ç√≥w do losowania.";
              elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
              elements.length.textContent = "D≈Çugo≈õƒá has≈Ça: ‚Äî";
              elements.source.textContent = `≈πr√≥d≈Ço: ${sourceFileName}`;
              elements.copy.disabled = true;
              continue;
            }
            
            const password = buildPassword(min, max, strip, minWords, wordList);

            if (!password) {
              elements.password.textContent = "Nie uda≈Ço siƒô wygenerowaƒá has≈Ça w tym zakresie.";
              elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
              elements.length.textContent = "D≈Çugo≈õƒá has≈Ça: ‚Äî";
              elements.source.textContent = `≈πr√≥d≈Ço: ${sourceFileName}`;
              elements.copy.disabled = true;
              continue;
            }

            elements.password.textContent = password;
            elements.transcription.textContent = transcribePassword(password);
            elements.length.textContent = `D≈Çugo≈õƒá has≈Ça: ${password.length} znak√≥w`;
            elements.source.textContent = `≈πr√≥d≈Ço: ${sourceFileName}`;
            elements.copy.disabled = false;
          } catch (error) {
            elements.password.textContent = "B≈ÇƒÖd wczytywania pliku ≈∫r√≥d≈Çowego";
            elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
            elements.length.textContent = "D≈Çugo≈õƒá has≈Ça: ‚Äî";
            elements.source.textContent = "≈πr√≥d≈Ço: ‚Äî";
            elements.copy.disabled = true;
          }
        }
      };

      const copyPassword = async (key) => {
        const elements = getElementsFor(key);
        const text = elements.password.textContent?.trim();
        if (!text || text === "≈Åadowanie‚Ä¶") return;

        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.setAttribute("readonly", "");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
          }

          const previous = elements.copy.textContent;
          elements.copy.textContent = "Skopiowano!";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        } catch {
          const previous = elements.copy.textContent;
          elements.copy.textContent = "Nie uda≈Ço siƒô";
          setTimeout(() => {
            elements.copy.textContent = previous;
          }, 1200);
        }
      };

      // Sprawdza, czy linijka spe≈Çnia minimalne wymagania
      const isValidLine = (line) => {
        const trimmed = line.trim();
        if (trimmed.length < MIN_CHARS_IN_LINE) return false;
        
        const wordsInLine = trimmed.split(/\s+/).filter(w => w.length > 0);
        return wordsInLine.length >= MIN_WORDS_IN_LINE;
      };

      // Wyodrƒôbnia s≈Çowa z linijki (bez znak√≥w interpunkcyjnych)
      const extractWordsFromLine = (line) => {
        return line
          .split(/\s+/)
          .map(word => removePunctuation(word).trim())
          .filter(word => word.length > 0);
      };

      // Pobiera losowy ciƒÖg nastƒôpujƒÖcych po sobie s≈Ç√≥w z linijki
      const getConsecutiveWords = (line, count) => {
        const lineWords = extractWordsFromLine(line);
        if (lineWords.length < count) return lineWords;
        
        const maxStartIndex = lineWords.length - count;
        const startIndex = Math.floor(Math.random() * (maxStartIndex + 1));
        return lineWords.slice(startIndex, startIndex + count);
      };

      // ≈Åaduje listƒô plik√≥w ≈∫r√≥d≈Çowych z sources.json
      const loadSourcesList = async () => {
        try {
          const response = await fetch('sources.json');
          if (!response.ok) {
            console.warn('Nie mo≈ºna za≈Çadowaƒá sources.json, u≈ºywam warto≈õci domy≈õlnych');
            // Fallback - warto≈õci domy≈õlne
            SOURCE_FILES = [
              "sources/ksiazka1.txt",
              "sources/ksiazka2.txt",
              "sources/ksiazka3.txt",
              "sources/ksiazka4.txt",
              "sources/ksiazka5.txt",
            ];
            return;
          }
          SOURCE_FILES = await response.json();
        } catch (error) {
          // Fallback - warto≈õci domy≈õlne
          SOURCE_FILES = [
            "sources/ksiazka1.txt",
            "sources/ksiazka2.txt",
            "sources/ksiazka3.txt",
            "sources/ksiazka4.txt",
            "sources/ksiazka5.txt",
          ];
        }
      };

      // ≈Åaduje s≈Çowa z podanego pliku ≈∫r√≥d≈Çowego
      const loadWordsFromFile = async (filePath) => {
        const response = await fetch(filePath);
        if (!response.ok) throw new Error(`Nie uda≈Ço siƒô wczytaƒá pliku: ${filePath}`);

        const text = await response.text();
        const lines = text.split(/\r?\n/);
        
        // Filtruj linijki spe≈ÇniajƒÖce wymagania
        const validLines = lines.filter(isValidLine);
        
        if (validLines.length === 0) {
          throw new Error("Brak linijek spe≈ÇniajƒÖcych wymagania.");
        }
        
        // Zbierz s≈Çowa z losowych linijek i losowych ciƒÖg√≥w s≈Ç√≥w
        const loadedWords = [];
        const linesToUse = Math.min(validLines.length, MAX_LINES_TO_USE);
        
        for (let i = 0; i < linesToUse; i++) {
          const randomLine = randomItem(validLines);
          // Losuj od 1 do 3 nastƒôpujƒÖcych po sobie s≈Ç√≥w z linijki
          const wordCount = Math.floor(Math.random() * 3) + 1;
          const consecutiveWords = getConsecutiveWords(randomLine, wordCount);
          loadedWords.push(...consecutiveWords);
        }
        
        // Usu≈Ñ duplikaty i puste warto≈õci
        return [...new Set(loadedWords)].filter(w => w.length > 1);
      };

      const exclusionStatsEl = document.getElementById("exclusion-stats");
      const clearExclusionsBtn = document.getElementById("clear-exclusions");

      // Aktualizuje wy≈õwietlanie statystyk wyklucze≈Ñ
      const updateExclusionStats = () => {
        const count = getExclusionStats();
        exclusionStatsEl.textContent = `Wykluczone s≈Çowa: ${count} (wygasajƒÖ po 31 dniach)`;
      };

      // Czy≈õci wszystkie wykluczenia
      clearExclusionsBtn.addEventListener("click", () => {
        localStorage.removeItem(EXCLUSION_STORAGE_KEY);
        updateExclusionStats();
        clearExclusionsBtn.textContent = "Wyczyszczono!";
        setTimeout(() => {
          clearExclusionsBtn.textContent = "Wyczy≈õƒá historiƒô";
        }, 1200);
      });

      regenBtn.addEventListener("click", async () => {
        // Poka≈º wizualny feedback ≈Çadowania
        regenBtn.classList.add("loading");
        regenBtn.disabled = true;

        try {
          // Generuj has≈Ça (ka≈ºde z innego pliku)
          await generatePasswords();
          updateExclusionStats();
        } finally {
          // Usu≈Ñ wizualny feedback
          regenBtn.classList.remove("loading");
          regenBtn.disabled = false;
        }
      });
      copyButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const key = button.dataset.copy;
          if (key) copyPassword(key);
        });
      });

      // Wyczy≈õƒá przeterminowane wykluczenia przy starcie
      cleanExpiredExclusions();
      updateExclusionStats();

      // Najpierw za≈Çaduj listƒô ≈∫r√≥de≈Ç, potem generuj has≈Ça
      loadSourcesList()
        .then(() => generatePasswords())
        .then(() => {
          updateExclusionStats();
        })
        .catch(() => {
          variants.forEach(({ key }) => {
            const elements = getElementsFor(key);
            elements.password.textContent = "B≈ÇƒÖd wczytywania plik√≥w z katalogu sources/";
            elements.transcription.textContent = "Transkrypcja niedostƒôpna.";
            elements.length.textContent = "D≈Çugo≈õƒá has≈Ça: ‚Äî";
            elements.source.textContent = "≈πr√≥d≈Ço: ‚Äî";
            elements.copy.disabled = true;
          });
        });
    </script>
  </body>
</html>
